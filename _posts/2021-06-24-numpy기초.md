```python
import numpy as np
```

파이썬의 list와 numpy의 ndarray의 차이점

* 파이썬의 리스트보다 속도가 훨씬 빠르다
* 파이썬의 리스트보다 배열을 훨씬 쉽게 다룰 수 있다.


```python
arr1 = np.array([1, 2, 3])
arr1
```




    array([1, 2, 3])




```python
type(arr1)
```




    numpy.ndarray




```python
# 2차원 배열 만들기 with python의 list

arr2 = np.array([[1, 2, 3,],
                 [4, 5, 6,]])
type(arr2)
```




    numpy.ndarray



np.arange


```python
arr = np.arange(10) # 0 ~ 9 까지 들어있는 숫자 배열
arr 
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
arr = np.arange(1, 10) # 1 ~ 9 까지 들어있는 숫자 배열
arr
```




    array([1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
arr = np.arange(1, 10, 2) # 1부터 9까지 2씩 띄워가면서 풀력
arr
```




    array([1, 3, 5, 7, 9])



다차원 배열
* np.zeros
* np.ones
* np.full

# np.zeros
지정된 차원에 모든 원소를 0으로 채운다.


```python
np.zeros(5) # 1차원 배열에 5개의 0을 채운다.
```


```python
np.zeros((4, 5)) # 4행 5열(2차원 배열)의 배열에 0을 채운다.
```




    array([[0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.]])




```python
np.zeros((3, 4, 5)) # 3차원 배열에 0을 채운다.
```




    array([[[0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.]],
    
           [[0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.]],
    
           [[0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.]]])



np.ones
지정한 차원에 모든 원소를 1로 채운다.


```python
np.ones(5)
```




    array([1., 1., 1., 1., 1.])




```python
np.ones((2, 3))
```




    array([[1., 1., 1.],
           [1., 1., 1.]])




```python
np.ones((3, 4, 5))
```




    array([[[1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.]],
    
           [[1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.]],
    
           [[1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.]]])




```python
np.ones((2, 3)) * 5
```




    array([[5., 5., 5.],
           [5., 5., 5.]])



np.full

지정한 차원의 배열에 원하는 수를 채워 넣는다.


```python
np.full((3, 4,), 7)
```




    array([[7, 7, 7, 7],
           [7, 7, 7, 7],
           [7, 7, 7, 7]])



단위 행렬 만들기
* np.eye


```python
np.eye(3)

```




    array([[1., 0., 0.],
           [0., 1., 0.],
           [0., 0., 1.]])




```python
np.eye(3, 4)
```




    array([[1., 0., 0., 0.],
           [0., 1., 0., 0.],
           [0., 0., 1., 0.]])



구간 나누기
* np.linspace


```python
np.linspace(1, 10, 3) # 1부터 10까지 3개의 구간 만들기
```




    array([ 1. ,  5.5, 10. ])




```python
np.linspace(1, 10, 4) # 1부터 10까지 4개의 구간 만들기
```


```python
np.linspace(1, 10 ,5) # 1부터 10까지 5개의 구간 만들기
```




    array([ 1.  ,  3.25,  5.5 ,  7.75, 10.  ])



Random을 사용하기 위한 numpy
* 보통 랜덤한 배열은 딥러닝에서 매개변수의 초기화를 하기 위해 사용한다.
* 딥러닝에서는 일반적으로 Xavier 초깃값, He 초깃갑, 정규분포 초깃값을 계산해 준다.


```python
# 일반적인 랜덤값만 만들기 ( 균등분포 x , 정규분포 x)
np.random.rand(2, 3) # 0 ~ 1 사이의 랜덤값 만들기

```


```python
# 정규분포 랜덤값 만들기
np.random.randn(10)
```




    array([ 0.6297265 , -1.7163069 ,  0.07565697,  0.93082743,  0.17314181,
            0.56548991,  0.30852017,  1.23917149,  1.23741538, -1.09514884])




```python
np.random.randn(3, 4, 2)
# 균등 분포 만들기
np.random.uniform(1.0, 3.0, size(4, 5)) # size로 배열의 형상(shape)지정
```




    array([[[-1.12554761, -0.74003997],
            [ 1.85639689, -0.0583032 ],
            [ 0.20907541, -0.12596517],
            [-0.08538032, -0.49087093]],
    
           [[-0.271572  ,  0.88044371],
            [ 1.20707194, -1.40014968],
            [-0.67219322, -1.87686638],
            [-0.624918  , -2.26878462]],
    
           [[ 1.33849784, -0.1561756 ],
            [ 0.79385004, -0.06448674],
            [-0.89461926, -1.64183076],
            [ 0.80161061, -1.46091539]]])



# 정수 랜덤 만들기


```python
np.random.randint(1, 100, size = (5))
```




    array([72, 63, 76, 90, 36])




```python
np.random.randint(1, 100, size = (5, 1))
```




    array([[49],
           [63],
           [55],
           [78],
           [ 4]])




```python
np.random.randint(1, 100, size = (3, 4, 5))
```




    array([[[21,  9, 46, 53, 88],
            [13,  4, 13, 15, 46],
            [51, 78, 93, 47, 23],
            [71, 33, 96, 18, 66]],
    
           [[58, 40, 34, 39, 99],
            [84, 11,  8, 70, 32],
            [61, 65, 46, 36, 63],
            [85, 53, 40, 83, 45]],
    
           [[85, 95, 87, 19, 91],
            [15, 13, 36, 80, 34],
            [44, 99, 78, 38, 31],
            [ 4,  7, 76, 52, 95]]])




```python
# 1차원 배열에서 랜덤 샘플링 하기 (중복x)
# 미니배치를 만들 때 사용한다.
np.random.choice(100, size = 3, 4 )
```


```python
arr = np.arange(1, 6) # 1 ~ 5 사이의 숫자가 순서대로 들어왔음

np.random.choice(arr, size=(2, 2), replace = True) # True면 원소를 중복추출, False면 중복 추출 x

```

# 인덱스와 슬라이싱


```python
arr = np.arange(1, 11).reshape(2, 5)
arr
```




    array([[ 1,  2,  3,  4,  5],
           [ 6,  7,  8,  9, 10]])




```python
arr[0][2]
```




    3




```python
arr[0, 2]
```




    3




```python
arr = np.arange(36).reshape(3, 4, 3)
arr
```




    array([[[ 0,  1,  2],
            [ 3,  4,  5],
            [ 6,  7,  8],
            [ 9, 10, 11]],
    
           [[12, 13, 14],
            [15, 16, 17],
            [18, 19, 20],
            [21, 22, 23]],
    
           [[24, 25, 26],
            [27, 28, 29],
            [30, 31, 32],
            [33, 34, 35]]])




```python
arr[:, :2, :2]
```




    array([[[ 0,  1],
            [ 3,  4]],
    
           [[12, 13],
            [15, 16]],
    
           [[24, 25],
            [27, 28]]])




```python
arr[:2]
```

# 배열의 차원과 형상
* 형상(shape)
* 차원수(ndim)




```python
arr = np.arange(12).reshape(3, 4)
arr
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11]])




```python
arr.shape
```




    (3, 4)




```python
arr.ndim
```




    2



# 차원수 늘리기
* 이미지 분석(CNN)  레이어를 사용하기 위해서는 필수적으로 알아야 한다.


```python
# Tensorflow 기준으로 CNN에 사용되어지는 배열의 형상은 항상 다음과 같다.
arr2 = arr[np.newaxis, :, :, np.newaxis]
arr2.shape
# 1번째는 이미지 ,2번째는 가로 길이 3번째는 세로 길이 4번째는 채널의 갯수를 뜻한다.
# 주로 1번째 이미지와 4번째 채널의 갯수는 표시용으로 사용하지 실제 데이터에선 쓸모가 없는 편이다.
```




    (1, 3, 4, 1)




```python
arr2.ndim
```




    4




```python
arr2
```




    array([[[[ 0],
             [ 1],
             [ 2],
             [ 3]],
    
            [[ 4],
             [ 5],
             [ 6],
             [ 7]],
    
            [[ 8],
             [ 9],
             [10],
             [11]]]])




```python
arr3 = np.squeeze(arr2)
arr3.shape
```




    (3, 4)




```python
arr4 = arr[np.newaxis, ... , np.newaxis]
arr4.shape
```




    (1, 3, 4, 1)



# 배열의 형상 (shape) 바꾸기
* np.newaxis를 활용해서 축을 추가한다. ( 차원수를 늘린다.)

평탄화
* ravel()
* flatten()

형상 변환
* reshape()


```python
x = np.arange(15).reshape(3, 5)
x.shape
```




    (3, 5)




```python
# ravel : 평탄화 시킨 참조 배열을 낸다. (View 또는 Reference를 만들어 낸다.)
# flatten : 평탄화 시킨 복사 배열을 만들어 낸다.

temp = np.ravel(x)
print(temp)
```

    [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
    


```python
temp[0] = 100
print(x)
```

    [[100   1   2   3   4]
     [  5   6   7   8   9]
     [ 10  11  12  13  14]]
    


```python
y = np.arange(15).reshape(3, 5)
```


```python
temp2 = y.flatten() # y를 1차원으로 쭉 펴낸 배열을 "새롭게" 만들어 낸다.
print(temp2)
print(y)
```

    [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
    [[ 0  1  2  3  4]
     [ 5  6  7  8  9]
     [10 11 12 13 14]]
    


```python
temp2[0] = 100
print(temp2)
print(y)
```

    [100   1   2   3   4   5   6   7   8   9  10  11  12  13  14]
    [[ 0  1  2  3  4]
     [ 5  6  7  8  9]
     [10 11 12 13 14]]
    


```python
# reshape (배열의 형상을 바꾸기)
x = np.arange(20)
x
```




    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
           17, 18, 19])




```python
x.reshape(2, 5, 2)
```




    array([[[ 0,  1],
            [ 2,  3],
            [ 4,  5],
            [ 6,  7],
            [ 8,  9]],
    
           [[10, 11],
            [12, 13],
            [14, 15],
            [16, 17],
            [18, 19]]])




```python
x.reshape(2, 2, -1)
```




    array([[[ 0,  1,  2,  3,  4],
            [ 5,  6,  7,  8,  9]],
    
           [[10, 11, 12, 13, 14],
            [15, 16, 17, 18, 19]]])




```python
x.reshape(-1, 5).shape
```




    (4, 5)




```python
x.reshape(2, -1, 5).shape
```




    (2, 2, 5)



# 브로드 캐스팅
* 차원수가 다른 배열끼리의 연산


```python
x = np.arange(15).reshape(3, 5)
y = np.random.randn(15).reshape(3, 5)

print(x)
print(y)
```

    [[ 0  1  2  3  4]
     [ 5  6  7  8  9]
     [10 11 12 13 14]]
    [[-1.21762103  0.09607563 -0.75298632  1.04811693  0.16674236]
     [ 0.41265282  1.0493825   0.47264416  0.33858829 -1.25606879]
     [ 1.07811582  0.31988641 -0.35340631 -0.41284595 -1.05122125]]
    


```python
x + y
```




    array([[-1.21762103,  1.09607563,  1.24701368,  4.04811693,  4.16674236],
           [ 5.41265282,  7.0493825 ,  7.47264416,  8.33858829,  7.74393121],
           [11.07811582, 11.31988641, 11.64659369, 12.58715405, 12.94877875]])




```python
x * y
```




    array([[ -0.        ,   0.09607563,  -1.50597264,   3.1443508 ,
              0.66696945],
           [  2.06326409,   6.29629502,   3.30850915,   2.70870632,
            -11.30461909],
           [ 10.78115822,   3.51875056,  -4.24087573,  -5.36699735,
            -14.7170975 ]])




```python
x * 2 # x는 배열, 2는 스칼라값. 스칼라값이 브로드 캐스팅된다.
```




    array([[ 0,  2,  4,  6,  8],
           [10, 12, 14, 16, 18],
           [20, 22, 24, 26, 28]])




```python
a = np.arange(12).reshape(4, 3) # (4, 3)
b = np.arange(100, 103) # (3, )
c = np.arange(1000, 1004) #(4, )
d = b.reshape(1, 3) # (1, 3)

print(a.shape)
print(b.shape)
print(c.shape)
print(d.shape)
```

    (4, 3)
    (3,)
    (4,)
    (1, 3)
    


```python
a + b
```




    array([[100, 102, 104],
           [103, 105, 107],
           [106, 108, 110],
           [109, 111, 113]])




```python
a + c
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-96-e81e582b6fa9> in <module>()
    ----> 1 a + c
    

    ValueError: operands could not be broadcast together with shapes (4,3) (4,) 



```python
a + d
```




    array([[100, 102, 104],
           [103, 105, 107],
           [106, 108, 110],
           [109, 111, 113]])



# 전치행렬 만들기


```python
e = np.arange(6).reshape(2, 3)
e
```




    array([[0, 1, 2],
           [3, 4, 5]])




```python
e.T # T를 이용하여 행과 열의 인덱스를 바꾼다.
```




    array([[0, 3],
           [1, 4],
           [2, 5]])


